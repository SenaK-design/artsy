float step;
float radius;
float angle;
float rNoise, aNoise, xNoise, yNoise, vNoise, vNoise2, cNoise;
int figures[];
boolean inverse = true;

void setup() {
  size(512, 512);
  smooth();
  inverse = false;
  radius = width / 2.0;
  angle = 0;
  figures = new int[] {2, 3, 4};
  currentFigure = 0;
  xNoise = random(10);
  yNoise = random(10);
  rNoise = random(10);
  aNoise = random(10);
  vNoise = random(10);
  vNoise2 = random(10);
  cNoise = random(10);
  colorMode(HSB, 360, 100, 100);
  background(0);
  noFill();
}

void draw() {
  color c1 = color(321, 97, 97);
  color c2 = color(243, 76, 78);
  color stroke = lerpColor(c1, c2, abs(cos(angle)));

  strokeWeight(0.25);
  stroke(stroke);

  pushMatrix();

  float cx = width / 2 + (noise(xNoise) * 56) - 56/2.0;
  float cy = height / 2 + (noise(yNoise) * 56) - 56/2.0;

  translate(cx , cy);
  stroke(stroke);

  beginShape();


  for (int i = 0; i < 4; i++) {
    float r = radius * noise(rNoise);
    float rad = (angle + (i * (TWO_PI) / map(sin(angle), -1, 1, 2, 4)));

    //float rad = (angle + (i * ((noise(vNoise) * TWO_PI) / (noise(vNoise2) * 4))));
    float x = r * (cos(rad));
    float y = r * (sin(rad));
    vertex(x, y);

    vNoise += 0.00057;
    vNoise2 += 0.00027;
  }
  endShape(CLOSE);
  popMatrix();

  inverse = angle > TWO_PI || angle < 0 ? !inverse : inverse;
  angle += (inverse ? -1 : 1) * ((noise(aNoise) * PI / 128)); //- PI / 228);

  rNoise += 0.00768;
  aNoise += 0.000366;
  cNoise += 0.0567;
  xNoise += 0.01;
  yNoise += 0.01;

  if (sin(angle) >= 0.95) {
    currentFigure += currentFigure == figures.length - 1 ? 0 : 1;
  }
}
